{% extends 'dogovornoy/base.html' %}
{% load static %}

{% block content %}
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–°–ø–∏—Å–æ–∫ —Ç—Ä–µ–≤–æ–≥</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>  <!-- –ü–æ–¥–∫–ª—é—á–∞–µ–º Vue -->
</head>
<body>

<style>
    .status-btn {
        width: 150px;
        height: 60px;
        padding: 5px 10px;
        border: none;
        cursor: pointer;
        border-radius: 5px;
        color: white;
        font-weight: bold;
    }
.status-btn[data-status="new"] { background-color: red; }
.status-btn[data-status="pending"] { background-color: orange; }
.status-btn[data-status="in_progress"] { background-color: green; }
.table {
	max-width: 90%;
	margin-bottom: 20px;
	border: 1px solid #dddddd;
	border-collapse: collapse;
}
.table th {
	font-weight: bold;
	padding: 5px;
	background: #efefef;
	border: 1px solid #dddddd;
}
.table td {
	border: 1px solid #dddddd;
	padding: 5px;
}
.divster {
    width: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    margin-top: 70px;
}
</style>

    <h1>–°–ø–∏—Å–æ–∫ —Ç—Ä–µ–≤–æ–≥</h1>

    <div id="app">
        <div class="divster">
        <table border="1" class="table">
            <thead>
                <tr>
                    <th>–ö–ª–∏–µ–Ω—Ç</th>
                    <th>–ò–º—è –∫–ª–∏–µ–Ω—Ç–∞</th>
                    <th>–¢–∏–ø –æ–±—å–µ–∫—Ç–∞</th>
                    <th>–ê–¥—Ä–µ—Å</th>
                    <th>–û–ø–∏—Å–∞–Ω–∏–µ –æ–±—å–µ–∫—Ç–∞</th>
                    <th>–ú–∞—Ä—à—Ä—É—Ç —Å–ª–µ–¥–æ–≤–∞–Ω–∏—è</th>
                    <th>–¢–µ–ª–µ—Ñ–æ–Ω</th>
                    <th>–≠—Ç–∞–∂</th>
                    <th>–≠—Ç–∞–∂–µ–π</th>
                    <th>–ö–æ–¥ –¥–æ–º–æ—Ñ–æ–Ω–∞</th>
                    <th>–≠–∫–∏–ø–∞–∂</th>
                    <th>–ü–æ—Å–ª–µ–¥–Ω—è—è —Ç—Ä–µ–≤–æ–≥–∞</th>
                    <th>–í—Ä–µ–º—è</th>
                    <th>–°—Ç–∞—Ç—É—Å</th>
                </tr>
            </thead>
            <tbody>
                <tr v-for="(alarm, index) in alarms" :key="index">
                    <td>[[ getClientData(alarm.client_id, 'user__username') ]]</td>
                    <td>[[ getClientData(alarm.client_id, 'name_client') ]]</td>
                    <td>[[ getClientData(alarm.client_id, 'object_type')]]</td>
                    <td>[[ getClientData(alarm.client_id, 'address') ]]</td>
                    <td>[[ getClientData(alarm.client_id, 'description') ]]</td>
                    <td>[[ getClientData(alarm.client_id, 'route_info')]]</td>
                    <td>[[ getClientData(alarm.client_id, 'phone_number') ]]</td>
                    <td>[[ getClientData(alarm.client_id, 'floor') ]]</td>
                    <td>[[ getClientData(alarm.client_id, 'floor_total') ]]</td>
                    <td>[[ getClientData(alarm.client_id, 'intercom_code') ]]</td>
                    <td>[[ getClientData(alarm.client_id, 'ekipaz_panic') ]]</td>
                    <td>[[ formatDate(alarm.client_id, 'last_alarm_at') ]]</td>
                    <td>[[ formatDate(alarm.created_at) ]]</td>
                    <td>
                        <button @click="updateAlarmStatus(alarm.id)" class="status-btn" :data-status="alarm.status">
                            [[ statusLabels[alarm.status] || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ" ]]
                        </button>
                    </td>
                </tr>
            </tbody>
        </table>
            </div>
    </div>


<script>
    const { createApp, ref, onMounted, nextTick, watch } = Vue;

    const testMessage = ref("‚úÖ Vue —É—Å–ø–µ—à–Ω–æ –ø–æ–¥–∫–ª—é—á–µ–Ω!");

    createApp({
        delimiters: ['[[', ']]'],
        setup() {
            const alarms = ref([]);
            const apiToken = "{{ user_api_token }}";

            const clientNames = ref({});
            const clientData = ref({});

            const statusLabels = {
                "new": "–û–∂–∏–¥–∞–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏",
                "pending": "–í —Ä–∞–±–æ—Ç–µ",
                "in_progress": "–ó–∞–≤–µ—Ä—à–µ–Ω–æ"
            };

            function getClientName(client_id) {
                return clientNames.value[client_id] || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ";  // –ï—Å–ª–∏ –Ω–µ—Ç ID, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
            }

            function getClientData(client_id, field) {
                if (!clientData.value[client_id]) {
                    return "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ";
                }
                return clientData.value[client_id][field] || "–ù–µ —É–∫–∞–∑–∞–Ω–æ";
            }

            function loadClients() {
                fetch('/api/panicbutton/clients/', {
                    headers: { "Authorization": `Token ${apiToken}`, }
                })
                .then(response => response.json())
                .then(data => {
                    // –ó–∞–ø–æ–ª–Ω—è–µ–º –æ–±—ä–µ–∫—Ç clientNames
                    clientData.value = data.reduce((acc, client) => {
                        acc[client.user_id] = client;  // –°–æ–ø–æ—Å—Ç–∞–≤–ª—è–µ–º client.user_id -> –æ–±—ä–µ–∫—Ç –∫–ª–∏–µ–Ω—Ç–∞
                        return acc;
                    }, {});

                    console.log("üìã –ó–∞–≥—Ä—É–∂–µ–Ω—ã –∫–ª–∏–µ–Ω—Ç—ã:", clientData.value);
                })
                .catch(error => console.error("‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–ª–∏–µ–Ω—Ç–æ–≤:", error));
            }

            function updateAlarmStatus(alarmId) {
                const alarmIndex = alarms.value.findIndex(a => a.id === alarmId);
                if (alarmIndex === -1) return;

                const alarm = alarms.value[alarmIndex];

                // –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Å—Ç–∞—Ç—É—Å–æ–≤
                const statusFlow = ["new", "pending", "in_progress", "resolved"];
                const currentIndex = statusFlow.indexOf(alarm.status);

                if (currentIndex === -1 || currentIndex === statusFlow.length - 1) return;

                const newStatus = statusFlow[currentIndex + 1];

                console.log(`üîÑ –ú–µ–Ω—è–µ–º —Å—Ç–∞—Ç—É—Å —Ç—Ä–µ–≤–æ–≥–∏ ID ${alarmId} ‚Üí ${statusLabels[newStatus]}`);

                fetch(`/api/panicbutton/update_alarm_status/${alarmId}/`, {
                    method: "POST",
                    headers: {
                       "Authorization": `Token ${apiToken}`,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({ status: newStatus })
                })
                .then(response => response.json())
                .then(data => {
                    console.log("‚úÖ –°—Ç–∞—Ç—É—Å –æ–±–Ω–æ–≤–ª–µ–Ω:", data);

                    if (newStatus === "resolved") {
                        alarms.value.splice(alarmIndex, 1);  // –£–¥–∞–ª—è–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ "–ó–∞–≤–µ—Ä—à–µ–Ω–æ"
                        console.log(`üöÄ –¢—Ä–µ–≤–æ–≥–∞ ID ${alarmId} –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –∏ —É–¥–∞–ª–µ–Ω–∞!`);
                    } else {
                        alarms.value[alarmIndex].status = newStatus;  // –ü—Ä–æ—Å—Ç–æ –æ–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å
                    }
                })
                .catch(error => console.error("‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞:", error));
            }


            function loadAlarms() {
                console.log("üì° –ó–∞–ø—Ä–æ—Å —Ç—Ä–µ–≤–æ–≥...");
                fetch('/api/panicbutton/get_alarms/', {
                    headers: { "Authorization": `Token ${apiToken}` }
                })

                .then(response => response.json())
                .then(data => {
                    console.log("üì• –ó–∞–≥—Ä—É–∂–µ–Ω—ã —Ç—Ä–µ–≤–æ–≥–∏:", data);
                    alarms.value = data;
                })
                .catch(error => console.error("‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ç—Ä–µ–≤–æ–≥:", error));
            }

            function formatDate(dateString) {
                if (!dateString) return "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ";
                return new Date(dateString).toLocaleString("ru-RU", {
                    day: "2-digit",
                    month: "2-digit",
                    year: "numeric",
                    hour: "2-digit",
                    minute: "2-digit",
                    second: "2-digit"
                });
            }

            // === WebSocket ===
            const socket = new WebSocket("wss://kateryushin.pro/ws/alarms/");
            // const socket = new WebSocket("ws://127.0.0.1:8000/ws/alarms/");
            socket.onopen = function() {
                console.log("üîó WebSocket –ø–æ–¥–∫–ª—é—á–µ–Ω!");
            };

            let alarmAudio = new Audio('/static/sounds/alarm.mp3');

            socket.onmessage = async function(event) {
                try {
                    console.log("üì© –ü–æ–ª—É—á–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ WebSocket:", event.data);
                    const newAlarm = JSON.parse(event.data);
                    console.log("üö® –ù–æ–≤–∞—è —Ç—Ä–µ–≤–æ–≥–∞:", newAlarm);

                    // Check if the alarm already exists
                    const exists = alarms.value.some(alarm => alarm.id === newAlarm.id);
                    if (!exists) {
                        // Play the alarm sound
                        alarmAudio.play().catch(error => {
                            console.warn("üö® –ê–≤—Ç–æ–∑–∞–ø—É—Å–∫ –∑–≤—É–∫–∞ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω.");
                        });

                        // Optionally check if clientData for this alarm's client is missing
                        if (clientData.value[newAlarm.client_id]) {
                            fetch(`/api/panicbutton/client/${newAlarm.client_id}/`, {
                                headers: { "Authorization": `Token ${apiToken}` }
                            })
                            .then(response => response.json())
                            .then(client => {
                                // Add or update the client data for this client ID
                                clientData.value[newAlarm.client_id] = client;
                                console.log("üìã –û–±–Ω–æ–≤–ª–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –∫–ª–∏–µ–Ω—Ç–∞:", client);
                            })
                            .catch(error => console.error("‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö –∫–ª–∏–µ–Ω—Ç–∞:", error));
                        }


                        // Update the alarms list
                        alarms.value.unshift(newAlarm);

                        // Force Vue to update
                        await nextTick();
                        console.log("üîÑ –¢–∞–±–ª–∏—Ü–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞:", alarms.value);
                    }
                } catch (error) {
                    console.error("–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ WebSocket:", error);
                }
            };

            socket.onerror = function(error) {
                console.error("‚ùå –û—à–∏–±–∫–∞ WebSocket:", error);
            };

            socket.onclose = function(event) {
                console.warn("üî¥ WebSocket –æ—Ç–∫–ª—é—á–µ–Ω:", event);
            };

            watch(alarms, (newValue) => {
                console.log("üîÑ –ú–∞—Å—Å–∏–≤ alarms –æ–±–Ω–æ–≤–ª—ë–Ω:", newValue);
            });

            onMounted(() => {
                loadAlarms();
                loadClients();
            });

            return { alarms, formatDate, testMessage, getClientName, getClientData, updateAlarmStatus, statusLabels };
        }
    }).mount("#app");
</script>

</body>
{% endblock %}